---
title: "Aufbereiten der Immobilienmarktdaten"
format: html
---

# Setup

```{r}
#| message: false
#| warning: false

#library(mice) # Gibt Probleme mit tidyr::complete() vs mice::complete()
library(tidyverse)
library(vroom)
library(arrow)
```

# Import
Ich habe zuerst die verschiedenen .csv Dateien in eine Datei zusammengefasst:

```{bash}
#| eval: false

# Header von erster Datei in neue Datei `combined` schreiben
head -n 1 WMSUF1.csv > combined
for f in *.csv; do tail -n +2 "$f" >> combined; done
# Eventuell ist folgende Methode schneller:
# awk 'FNR>1' *.csv >> combined.csv
# Getestet habe ich es nicht.
```

# Kauf

Problem: In den Daten ab 2019 sind die `dupID_gen` komisch. Z.B. `Other missing,Other missing,Other missing,Other missing,Other missing,Other missing,Real-estate agent ,Other missing,1,8794233,"ID occurs once only, or first occurence of ID"` oder `Other missing,Other missing,Other missing,Other missing,Other missing,Other missing,Real-estate agent ,Other missing,2,8307328,Probably one spell`.

Vorest bereinige ich es daher nicht.

```{r}
vroom_col_kauf <- cols_only(
  obid = col_character(),
  gkz = col_character(),
  plz = col_character(),
  kaufpreis = col_double(),
  baujahr = col_integer(),
  wohnflaeche = col_double(),
  zimmeranzahl = col_double(),
  ajahr = col_integer(),
  amonat = col_integer(),
  jahr = col_integer(),
  emonat = col_integer(),
  r1_id = col_character(),
  dupID_gen = col_character()
)

good_dupIDs <- c("ID occurs once only, or first occurence of ID", "Large differences in important features", "Like (4) but time gape >6 months", "Like (1) but time gap >6 months")

import_vroom_kauf <- vroom("../Daten/Immo/Rohdaten/Kauf/combined", col_types = vroom_col_kauf)

import_vroom_kauf_clean <- import_vroom_kauf %>%
  filter(!r1_id %in% c("-11", "-9")) %>%
  #filter(dupID_gen %in% good_dupIDs) %>%
  select(-dupID_gen) %>%
  drop_na(kaufpreis) %>%
  filter(kaufpreis %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  mutate(baujahr = na_if(baujahr, -1)) %>%
  rename(ejahr = jahr) %>%
  mutate(x_mp = r1_id %>% str_extract("^\\d{4}") %>% as.numeric(),
         y_mp = r1_id %>% str_extract("\\d{4}$") %>% as.numeric(),
         x_mp = x_mp * 1000 + 500,
         y_mp = y_mp * 1000 + 500)

import_vroom_kauf_clean %>%
  group_by(ejahr) %>%
  write_dataset("../Daten/Immo/Kauf/")
```

```{r}
open_dataset("../Daten/Immo/Kauf/") %>%
  group_by(ejahr) %>%
  count() %>%
  collect()
```


# Miete

Gleiches Problem mit `dupID_gen` wie oben. Vorest bereinige ich es daher nicht.

```{r}
vroom_col_miete <- cols_only(
  obid = col_character(),
  gkz = col_character(),
  plz = col_character(),
  mietekalt = col_double(),
  baujahr = col_integer(),
  wohnflaeche = col_double(),
  zimmeranzahl = col_double(),
  ajahr = col_integer(),
  amonat = col_integer(),
  jahr = col_integer(),
  emonat = col_integer(),
  r1_id = col_character(),
  dupID_gen = col_character()
)

good_dupIDs <- c("ID occurs once only, or first occurence of ID", "Large differences in important features", "Like (4) but time gape >6 months", "Like (1) but time gap >6 months")

import_vroom_miete <- vroom("../Daten/Immo/Rohdaten/Miete/combined", col_types = vroom_col_miete)

import_vroom_miete_clean <- import_vroom_miete %>%
  filter(!r1_id %in% c("-11", "-9")) %>%
  #filter(dupID_gen %in% good_dupIDs) %>%
  select(-dupID_gen) %>%
  drop_na(mietekalt) %>%
  drop_na(wohnflaeche) %>%
  filter(mietekalt %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  filter(wohnflaeche %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  mutate(baujahr = na_if(baujahr, -1)) %>%
  rename(ejahr = jahr) %>%
  mutate(x_mp = r1_id %>% str_extract("^\\d{4}") %>% as.numeric(),
         y_mp = r1_id %>% str_extract("\\d{4}$") %>% as.numeric(),
         x_mp = x_mp * 1000 + 500,
         y_mp = y_mp * 1000 + 500)

import_vroom_miete_clean %>%
  group_by(ejahr) %>%
  write_dataset("../Daten/Immo/Miete/")
```

Achtung: bei `import_vroom_miete_clean` sind nur Daten bis 2019. Irgendwie werden also spätere Anzeigen alle rausgefiltert. Möglicherweise wegen der `dupID_gen`.

```{r}
import_vroom_miete_clean_test <- import_vroom_miete %>%
  filter(!r1_id %in% c("-11", "-9")) %>%
  #filter(dupID_gen %in% good_dupIDs) %>%
  #select(-dupID_gen) %>%
  drop_na(mietekalt) %>%
  drop_na(wohnflaeche) %>%
  filter(mietekalt %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  filter(wohnflaeche %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  mutate(baujahr = na_if(baujahr, -1)) %>%
  rename(ejahr = jahr) %>%
  mutate(x_mp = r1_id %>% str_extract("^\\d{4}") %>% as.numeric(),
         y_mp = r1_id %>% str_extract("\\d{4}$") %>% as.numeric(),
         x_mp = x_mp * 1000 + 500,
         y_mp = y_mp * 1000 + 500)

import_vroom_miete_clean_test %>%
  filter(ejahr > 2019) %>%
  count(dupID_gen)
```

```{r}
open_dataset("../Daten/Immo/Miete/") %>%
  group_by(ejahr) %>%
  count() %>%
  collect()
```

# RWI GEO REDX PUF

HK = House sales, WK = Apartment sales, WM = Apartment rents, CI = Combined Index

```{r}
rwi_geo_redx_puf <- readxl::read_xlsx("../Daten/RWI_GEO_REDX_PUF/RWIGEOREDX_GRIDS_v13_PUF.xlsx",
                          sheet = "Grids_RegionEff_yearly") %>%
  pivot_longer(
    cols = starts_with(c("pindex", "NOBS")),
    names_to = c(".value", "year"),
    names_pattern = "(pindex|NOBS)(\\d{4})"
  ) %>%
  rename(nobs = NOBS) %>%
  mutate(x_mp = grid %>% str_extract("^\\d{4}") %>% as.numeric(),
         y_mp = grid %>% str_extract("\\d{4}$") %>% as.numeric(),
         x_mp = x_mp * 1000 + 500,
         y_mp = y_mp * 1000 + 500,
         .keep = "unused",
         .before = 1) %>%
  pivot_wider(names_from = housing_type, values_from = c(pindex, nobs)) %>%
  mutate(year = as.numeric(year))

rwi_geo_redx_puf %>%
  write_parquet("../Daten/RWI_GEO_REDX_PUF/rwi_geo_redx_puf.parquet")
```

```{r}
rwi_geo_redx_puf %>%
  inner_join(
    cells_gemeinden_bbsr %>%
      filter(gemeindetyp_differenziert_name == "Größere Großstadt")
  ) %>%
  filter(year >= 2018)
```

# RWI GEO RED aggregieren

Definieren von Pseudo-Daten (halbjährlich). Von der `did` Funktion werden Zeitpunkte benötigt. Jahre wäre zu grob, Monate wahrscheinlich zu fein. Ein guter Kompromiss sind daher halbjahre. Diese stimmen dann auch mit den Breitband Meldungen überein.

Ich fange bei 2017 an, dann gibt es einen gewissen Zeitraum, um Pretrends zu testen.

```{r}
min_date <- 201601
max_date <- 202406

dates_pseudo_halbjahr <- tibble(date = seq(
  from = ym(min_date),
  to = ym(max_date),
  by = "1 month"
)) %>%
  mutate(date = as.numeric(format(date, "%Y%m"))) %>%
  left_join(
    tibble(date = seq(
      from = ym(min_date),
      to = ym(max_date),
      by = "6 months"
      )) %>%
      mutate(date = as.numeric(format(date, "%Y%m")),
             date_pseudo_halbjahr = seq_along(date)),
    by = join_by(date)
    ) %>%
  fill(date_pseudo_halbjahr, .direction = "down")

dates_pseudo_halbjahr %>%
  write_parquet("../Daten/dates_pseudo_halbjahr.parquet")
```

Erklärende Variablen etc. laden, verbinden und imputieren.

Hinweis zu `gemeindetyp_differenziert_name`: Dies soll später als Robustheitscheck verwendet werden können, deswegen nehme ich es mit. Allerdings hat mice bei der Imputierung Probleme, weil es zu ähnlich zu `gemeindetyp_name` ist. Daher verwende ich diesen nicht als erklärende Variable bei der Imputierung.

```{r}
# Laden
got_fiber_dates <- read_parquet("../Daten/Breitbandatlas//Raster_1km_got_fiber_date.parquet") %>%
  left_join(dates_pseudo_halbjahr, by = join_by(got_fiber_date == date)) %>%
  rename(got_fiber_date_pseudo_halbjahr = date_pseudo_halbjahr)

cells_plz <- read_parquet("../Daten/Geodaten/Raster_1km_plz.parquet")

cells_gemeinden_bbsr <- read_parquet("../Daten/Raumgliederung_BBSR/Raster_1km_gemeinden_bbsr.parquet")

cells_kreise_einkommen <- read_parquet("../Daten/Geodaten/Raster_1km_kreise_einkommen.parquet")

cells_baujahr <- open_dataset("../Daten/Zensus/Gesamt/") %>%
  filter(typ == "1km") %>%
  select(x_mp, y_mp, vor1919:a2020undspaeter) %>%
  to_duckdb() %>%
  pivot_longer(cols = -c(x_mp, y_mp), names_to = "mode_baujahr", values_to = "anzahl") %>%
  group_by(x_mp, y_mp) %>%
  slice_max(order_by = anzahl, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  collect() %>%
  mutate(mode_baujahr = if_else(is.na(anzahl), NA, mode_baujahr)) %>%
  mutate(mode_baujahr = fct_relevel(mode_baujahr, c("vor1919", "a1919bis1948", "a1949bis1978", "a1979bis1990", "a1991bis2000", "a2020undspaeter"))) %>%
  select(x_mp, y_mp, mode_baujahr)

cells_zensus_sonst <- open_dataset("../Daten/Zensus/Gesamt/") %>%
  filter(typ == "1km") %>%
  mutate(anzahl_haushalte = einwohner / durchschn_hh_groesse) %>%
  select(x_mp, y_mp, durchschnittsalter, anzahl_haushalte, insgesamt_gebaeude, eigentuemerquote) %>%
  collect()

# Joinen und Imputieren
erklärende_imp <- cells_zensus_sonst %>%
  full_join(cells_baujahr, by = join_by(x_mp, y_mp)) %>%
  full_join(cells_gemeinden_bbsr, by = join_by(x_mp, y_mp)) %>%
  full_join(cells_kreise_einkommen, by = join_by(x_mp, y_mp)) %>%
  select(x_mp, y_mp, durchschnittsalter, anzahl_haushalte, insgesamt_gebaeude, eigentuemerquote, mode_baujahr, einkommen, einkommen_delta, gemeindetyp_name, gemeindetyp_differenziert_name) %>%
  mutate(imputed = if_else(!complete.cases(.), TRUE, FALSE)) %>%
  #filter(!complete.cases(.)) %>%
  mice::mice(m = 1, maxit = 1,
             pred = mice::quickpred(., exclude = c("x_mp", "y_mp", "imputed", "gemeindetyp_differenziert_name")), 
             seed = 1) %>%
  mice::complete() %>%
  as_tibble()
```

## Kauf

Hier werden die Kauf-Daten zu einem Index auf Rasterebene aggregiert. Im Idealfall gibt es pro Zelle für jede Zeitperiode (halbes Jahr) genügend Beobachtungen, aus denen dann der Mittelwert bestimmt wird. Dies ist jedoch für viele Zellen (in ländlicheren Gegenden) nicht der Fall. Daher erstelle ich mit `tidyr::complete()` zuerst alle Kombinationen aus den Zeitperioden und Zellen. Anschließend werden die fehlenden Daten mit `tidyr::fill()` aufgefüllt. Damit es aber später nachvollziehbar bleibt, gibt es die `n_cell` und `n_cell_date` Variablen, die zeigen wieviele Beobachtungen es für die Zelle insgesamt bzw. zu jeden Zeitpunkt gibt.

```{r}
# Einlesen
data_kauf <- open_dataset("../Daten/Immo/Kauf/") %>%
  filter(ejahr >= 2016) %>%
  mutate(date = ejahr*100 + emonat) %>%
  select(date, x_mp, y_mp, kaufpreis, baujahr, wohnflaeche, zimmeranzahl) %>%
  collect() %>%
  left_join(dates_pseudo_halbjahr, by = join_by(date)) %>%
  select(date_pseudo_halbjahr, x_mp, y_mp, kaufpreis, baujahr, wohnflaeche, zimmeranzahl)

# Imputieren, insb. das Baujahr
data_kauf_imp <- data_kauf %>%
  mice::mice(m = 1, maxit = 1, method = "pmm", pred = mice::quickpred(., exclude = c("x_mp", "y_mp")), seed = 1) %>%
  mice::complete() %>%
  as_tibble()

# Aggregieren und vervollständigen
data_kauf_complete <- data_kauf_imp %>%
  group_by(date_pseudo_halbjahr, x_mp, y_mp) %>%
  summarise(mean_kaufpreis = mean(kaufpreis),
            n_cell_date = n(),
            median_baujahr = median(baujahr),
            median_wohnflaeche = median(wohnflaeche),
            median_zimmeranzahl = median(zimmeranzahl),
            .groups = "drop") %>%
  arrange(x_mp, y_mp, date_pseudo_halbjahr) %>%
  group_by(x_mp, y_mp) %>%
  mutate(n_cell = sum(n_cell_date)) %>%
  ungroup() %>%
  mutate(xy_mp = (x_mp-500)*10 + (y_mp-500)/1000) %>%
  complete(xy_mp, date_pseudo_halbjahr) %>%
  group_by(xy_mp) %>%
  fill(everything(), -n_cell_date, .direction = "downup") %>%
  ungroup() %>%
  mutate(n_cell_date = replace_na(n_cell_date, 0)) %>%
  inner_join(erklärende_imp, by = join_by(x_mp, y_mp)) %>%
  inner_join(cells_plz, by = join_by(x_mp, y_mp)) %>%
  left_join(got_fiber_dates, by = join_by(x_mp, y_mp)) %>%
  mutate(got_fiber_date = replace_na(got_fiber_date, 0),
         got_fiber_date_pseudo_halbjahr = replace_na(got_fiber_date_pseudo_halbjahr, 0))

write_parquet(data_kauf_complete, "../Daten/data_kauf_complete.parquet")
```

Wieviele Beobachtungen gibts so?

```{r}
data_kauf_missing <- data_kauf_complete %>%
  select(x_mp, y_mp, n_cell_date) %>%
  group_by(x_mp, y_mp) %>%
  summarise(
    has_missing = any(n_cell_date == 0),
    missing_count = sum(n_cell_date == 0),
    .groups = "drop"
  ) %>%
  filter(has_missing) %>%
  select(x_mp, y_mp, missing_count)

data_kauf_missing %>% pull(missing_count) %>% quantile()
```

```{r}
top_cells <- data_kauf_complete %>%
  arrange(desc(n_cell)) %>%
  distinct(xy_mp, n_cell) %>%
  head(1000) %>%
  pull(xy_mp)

data_kauf_complete %>%
  #filter(xy_mp == "45543277") %>%
  filter(xy_mp %in% top_cells) %>%
  ggplot(aes(x = date_pseudo_halbjahr, y = mean_kaufpreis, group = as.factor(xy_mp)))+
  geom_line(alpha = .1)+
  scale_y_log10()+
  scale_x_continuous(breaks = 0:16)

data_kauf_complete %>%
  arrange(desc(n_cell)) %>%
  distinct(xy_mp, n_cell) %>%
  head(10) %>%
  pull(xy_mp)
```

## Miete

Analog zu den Kauf-Daten.

```{r}
# Einlesen
data_miete <- open_dataset("../Daten/Immo/Miete/") %>%
  filter(ejahr >= 2016) %>%
  mutate(date = ejahr*100 + emonat) %>%
  mutate(mietekalt_m2 = mietekalt / wohnflaeche) %>%
  select(date, x_mp, y_mp, mietekalt_m2, baujahr, wohnflaeche, zimmeranzahl) %>%
  collect() %>%
  left_join(dates_pseudo_halbjahr, by = join_by(date)) %>%
  select(date_pseudo_halbjahr, x_mp, y_mp, mietekalt_m2, baujahr, wohnflaeche, zimmeranzahl)

# Imputieren, insb. das Baujahr
data_miete_imp <- data_miete %>%
  mice::mice(m = 1, maxit = 1, method = "pmm", pred = mice::quickpred(., exclude = c("x_mp", "y_mp")), seed = 1) %>%
  mice::complete() %>%
  as_tibble()

# Aggregieren und vervollständigen
data_miete_complete <- data_miete_imp %>%
  group_by(date_pseudo_halbjahr, x_mp, y_mp) %>%
  summarise(mean_mietekalt_m2 = mean(mietekalt_m2),
            n_cell_date = n(),
            median_baujahr = median(baujahr),
            median_wohnflaeche = median(wohnflaeche),
            median_zimmeranzahl = median(zimmeranzahl),
            .groups = "drop") %>%
  arrange(x_mp, y_mp, date_pseudo_halbjahr) %>%
  group_by(x_mp, y_mp) %>%
  mutate(n_cell = sum(n_cell_date)) %>%
  ungroup() %>%
  mutate(xy_mp = (x_mp-500)*10 + (y_mp-500)/1000) %>%
  complete(xy_mp, date_pseudo_halbjahr) %>%
  group_by(xy_mp) %>%
  fill(everything(), -n_cell_date, .direction = "downup") %>%
  ungroup() %>%
  mutate(n_cell_date = replace_na(n_cell_date, 0)) %>%
  inner_join(erklärende_imp, by = join_by(x_mp, y_mp)) %>%
  inner_join(cells_plz, by = join_by(x_mp, y_mp)) %>%
  left_join(got_fiber_dates, by = join_by(x_mp, y_mp)) %>%
  mutate(got_fiber_date_pseudo_halbjahr = replace_na(got_fiber_date_pseudo_halbjahr, 0))

write_parquet(data_miete_complete, "../Daten/data_miete_complete.parquet")
```

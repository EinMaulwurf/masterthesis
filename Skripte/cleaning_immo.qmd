---
title: "Aufbereiten der Immobilienmarktdaten"
format: html
---

# Setup

```{r}
#| message: false
#| warning: false

#library(mice) # Gibt Probleme mit tidyr::complete() vs mice::complete()
library(tidyverse)
library(vroom)
library(arrow)
```

# Einlesen & Bereinigen

`dupID_gen`:
- 0: ObjektID only once or 1st spell of ObjektID
- 1: Probably belongs together, e.g. interruption due to delivery to RWI or slight adaptation of the advertisement
- 2: As (1), but gap between advertisements >6 months, i.e. it could also be a new rental of the apartment e.g.
- 3: Advertisements close together in time (<= 6 months), but differentiation in important variables
- 4: As (3), but gap between advertisements >6 months
- 5: Clear differences in important variables, so there are doubts that it is the same object.

## Kauf

```{r}
col_kauf <- c(
  "kaufpreis", "plz", "baujahr", "wohnflaeche", "zimmeranzahl",
  "ajahr", "amonat", "ejahr", "emonat", "ergg_1km", "dupID_gen"
)

cells_plz <- read_parquet("../Daten/Geodaten/Raster_1km_plz.parquet")
```

```{r}
import_hk <- read_parquet("../Daten/RWI_GEO_REDX/Daten_Kauf/HK_SUF_ohneText.parquet",
                          col_select = all_of(col_kauf)) %>%
  haven::zap_labels() %>%
  haven::zap_formats() %>%
  haven::zap_label() %>%
  haven::zap_missing() %>%
  haven::zap_widths() %>%
  mutate(typ = "Haus")

import_wk <- read_parquet("../Daten/RWI_GEO_REDX/Daten_Kauf/WK_SUF_ohneText.parquet",
                          col_select = all_of(col_kauf)) %>%
  haven::zap_labels() %>%
  haven::zap_formats() %>%
  haven::zap_label() %>%
  haven::zap_missing() %>%
  haven::zap_widths() %>%
  mutate(typ = "Wohnung")
```

Verbinden und bereinigen

```{r}
data_kauf <- bind_rows(import_hk, import_wk) %>%
  # Filtern
  filter(ajahr >= 2016) %>%
  filter(!ergg_1km %in% c("-11", "-9")) %>%
  drop_na(kaufpreis) %>%
  filter(kaufpreis %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  filter(dupID_gen %in% c(0, 4, 5)) %>%
  select(-dupID_gen) %>%
  distinct(kaufpreis, plz, baujahr, wohnflaeche, zimmeranzahl, ajahr, ejahr, ergg_1km, .keep_all = TRUE) %>%
  # Abändern
  mutate(across(c("plz"), as.character)) %>%
  mutate(baujahr = if_else(baujahr > 1000, baujahr, NA),
         plz = if_else(nchar(plz) == 5, plz, NA)) %>%
  mutate(x_mp = ergg_1km %>% str_extract("^\\d{4}") %>% as.numeric(),
         y_mp = ergg_1km %>% str_extract("\\d{4}$") %>% as.numeric(),
         x_mp = x_mp * 1000 + 500,
         y_mp = y_mp * 1000 + 500,
         .keep = "unused") %>%
  # fehlende PLZ hinzufügen
  left_join(cells_plz, by = join_by(x_mp, y_mp)) %>%
  mutate(plz = coalesce(plz.x, plz.y),
         .keep = "unused",
         .before = baujahr)

data_kauf %>%
  write_parquet("../Daten/RWI_GEO_REDX/Daten_Kauf/data_kauf.parquet")
```

## Miete

```{r}
col_miete <- c(
  "mietekalt", "plz", "baujahr", "wohnflaeche", "zimmeranzahl",
  "ajahr", "amonat", "ejahr", "emonat", "ergg_1km", "dupID_gen"
)
```

```{r}
import_hm <- read_parquet("../Daten/RWI_GEO_REDX/Daten_Miete/HM_SUF_ohneText.parquet",
                          col_select = all_of(col_miete)) %>%
  haven::zap_labels() %>%
  haven::zap_formats() %>%
  haven::zap_label() %>%
  haven::zap_missing() %>%
  haven::zap_widths() %>%
  mutate(typ = "Haus")

import_wm <- read_parquet("../Daten/RWI_GEO_REDX/Daten_Miete/WM_SUF_ohneText.parquet",
                          col_select = all_of(col_miete)) %>%
  haven::zap_labels() %>%
  haven::zap_formats() %>%
  haven::zap_label() %>%
  haven::zap_missing() %>%
  haven::zap_widths() %>%
  mutate(typ = "Wohnung")
```

Verbinden

```{r}
data_miete <- bind_rows(import_hm, import_wm) %>%
  # Filtern
  filter(ajahr >= 2016) %>%
  filter(!ergg_1km %in% c("-11", "-9")) %>%
  drop_na(mietekalt, wohnflaeche) %>%
  filter(mietekalt %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  filter(wohnflaeche %>% between(., quantile(., 0.01), quantile(., 0.99))) %>%
  filter(dupID_gen %in% c(0, 4, 5)) %>%
  select(-dupID_gen) %>%
  distinct(mietekalt, wohnflaeche, plz, baujahr, wohnflaeche, zimmeranzahl, ajahr, ejahr, ergg_1km, .keep_all = TRUE) %>%
  # Abändern
  mutate(across(c("plz"), as.character)) %>%
  mutate(baujahr = if_else(baujahr > 1000, baujahr, NA),
         plz = if_else(nchar(plz) == 5, plz, NA)) %>%
  mutate(mietekalt_m2 = mietekalt / wohnflaeche, .before = 1) %>%
  select(-mietekalt) %>%
  mutate(x_mp = ergg_1km %>% str_extract("^\\d{4}") %>% as.numeric(),
         y_mp = ergg_1km %>% str_extract("\\d{4}$") %>% as.numeric(),
         x_mp = x_mp * 1000 + 500,
         y_mp = y_mp * 1000 + 500) %>%
  # fehlende PLZ hinzufügen
  left_join(cells_plz, by = join_by(x_mp, y_mp)) %>%
  mutate(plz = coalesce(plz.x, plz.y),
         .keep = "unused",
         .before = baujahr)

data_miete %>%
  write_parquet("../Daten/RWI_GEO_REDX/Daten_Miete/data_miete.parquet")
```

# Imputieren und Ergänzen

## Pseude-Daten

Definieren von Pseudo-Daten (halbjährlich). Von der `did` Funktion werden Zeitpunkte benötigt. Jahre wäre zu grob, Monate wahrscheinlich zu fein. Ein guter Kompromiss sind daher halbjahre. Diese stimmen dann auch mit den Breitband Meldungen überein.

Ich fange bei 2017 an, dann gibt es einen gewissen Zeitraum, um Pretrends zu testen.

```{r}
min_date <- 201601
max_date <- 202406

dates_pseudo_halbjahr <- tibble(date = seq(
  from = ym(min_date),
  to = ym(max_date),
  by = "1 month"
)) %>%
  mutate(date = as.numeric(format(date, "%Y%m"))) %>%
  left_join(
    tibble(date = seq(
      from = ym(min_date),
      to = ym(max_date),
      by = "6 months"
      )) %>%
      mutate(date = as.numeric(format(date, "%Y%m")),
             date_pseudo_halbjahr = seq_along(date)),
    by = join_by(date)
    ) %>%
  fill(date_pseudo_halbjahr, .direction = "down")

dates_pseudo_halbjahr %>%
  write_parquet("../Daten/dates_pseudo_halbjahr.parquet")
```

## Erklärende Variablen

Erklärende Variablen etc. laden, verbinden und imputieren.

Hinweis zu `gemeindetyp_differenziert_name`: Dies soll später als Robustheitscheck verwendet werden können, deswegen nehme ich es mit. Allerdings hat mice bei der Imputierung Probleme, weil es zu ähnlich zu `gemeindetyp_name` ist. Daher verwende ich diesen nicht als erklärende Variable bei der Imputierung.

```{r}
# Laden
got_fiber_dates <- read_parquet("../Daten/Breitbandatlas//Raster_1km_got_fiber_date.parquet") %>%
  left_join(dates_pseudo_halbjahr, by = join_by(got_fiber_date == date)) %>%
  rename(got_fiber_date_pseudo_halbjahr = date_pseudo_halbjahr)

cells_plz <- read_parquet("../Daten/Geodaten/Raster_1km_plz.parquet")

cells_gemeinden_bbsr <- read_parquet("../Daten/Raumgliederung_BBSR/Raster_1km_gemeinden_bbsr.parquet")

cells_kreise_einkommen <- read_parquet("../Daten/Geodaten/Raster_1km_kreise_einkommen.parquet")

cells_gemeinden_gebäudetypen <- read_parquet("../Daten/Geodaten/Raster_1km_gemeinden_gebäudetypen.parquet")

cells_baujahr <- open_dataset("../Daten/Zensus/Gesamt/") %>%
  filter(typ == "1km") %>%
  select(x_mp, y_mp, vor1919:a2020undspaeter) %>%
  to_duckdb() %>%
  pivot_longer(cols = -c(x_mp, y_mp), names_to = "mode_baujahr", values_to = "anzahl") %>%
  group_by(x_mp, y_mp) %>%
  slice_max(order_by = anzahl, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  collect() %>%
  mutate(mode_baujahr = if_else(is.na(anzahl), NA, mode_baujahr)) %>%
  mutate(mode_baujahr = fct_relevel(mode_baujahr, c("vor1919", "a1919bis1948", "a1949bis1978", "a1979bis1990", "a1991bis2000", "a2020undspaeter"))) %>%
  select(x_mp, y_mp, mode_baujahr)

cells_zensus_sonst <- open_dataset("../Daten/Zensus/Gesamt/") %>%
  filter(typ == "1km") %>%
  mutate(anzahl_haushalte = einwohner / durchschn_hh_groesse) %>%
  select(x_mp, y_mp, durchschnittsalter, anzahl_haushalte, insgesamt_gebaeude, eigentuemerquote) %>%
  collect()

# Joinen und Imputieren
erklärende_imp <- cells_zensus_sonst %>%
  full_join(cells_baujahr, by = join_by(x_mp, y_mp)) %>%
  full_join(cells_gemeinden_bbsr, by = join_by(x_mp, y_mp)) %>%
  full_join(cells_kreise_einkommen, by = join_by(x_mp, y_mp)) %>%
  full_join(cells_gemeinden_gebäudetypen, by = join_by(x_mp, y_mp)) %>%
  select(x_mp, y_mp, durchschnittsalter, anzahl_haushalte, insgesamt_gebaeude, anteil_efh, eigentuemerquote, mode_baujahr, einkommen, einkommen_delta, gemeindetyp_name, gemeindetyp_differenziert_name) %>%
  mutate(imputed = if_else(!complete.cases(.), TRUE, FALSE)) %>%
  #filter(!complete.cases(.)) %>%
  mice::mice(m = 1, maxit = 1,
             pred = mice::quickpred(., exclude = c("x_mp", "y_mp", "imputed", "gemeindetyp_differenziert_name")), 
             seed = 1) %>%
  mice::complete() %>%
  as_tibble()
```

## Kauf

Hier werden die Kauf-Daten zu einem Index auf Rasterebene aggregiert. Im Idealfall gibt es pro Zelle für jede Zeitperiode (halbes Jahr) genügend Beobachtungen, aus denen dann der Mittelwert bestimmt wird. Dies ist jedoch für viele Zellen (in ländlicheren Gegenden) nicht der Fall. Daher erstelle ich mit `tidyr::complete()` zuerst alle Kombinationen aus den Zeitperioden und Zellen. Anschließend werden die fehlenden Daten mit `tidyr::fill()` aufgefüllt. Damit es aber später nachvollziehbar bleibt, gibt es die `n_cell` und `n_cell_date` Variablen, die zeigen wieviele Beobachtungen es für die Zelle insgesamt bzw. zu jeden Zeitpunkt gibt.

```{r}
# Einlesen
data_kauf <- read_parquet("../Daten/RWI_GEO_REDX/Daten_Kauf/data_kauf.parquet")

# Imputieren, insb. das Baujahr
data_kauf_imp <- data_kauf %>%
  mutate(date = ejahr*100 + emonat) %>%
  left_join(dates_pseudo_halbjahr, by = join_by(date)) %>%
  select(date_pseudo_halbjahr, x_mp, y_mp, kaufpreis, baujahr, wohnflaeche, zimmeranzahl) %>%
  mice::mice(m = 1, maxit = 1,
             pred = mice::quickpred(., exclude = c("x_mp", "y_mp")), 
             seed = 1) %>%
  mice::complete() %>%
  as_tibble()

# Aggregieren und vervollständigen
data_kauf_complete <- data_kauf_imp %>%
  group_by(date_pseudo_halbjahr, x_mp, y_mp) %>%
  summarise(mean_kaufpreis = mean(kaufpreis),
            n_cell_date = n(),
            median_baujahr = median(baujahr),
            median_wohnflaeche = median(wohnflaeche),
            median_zimmeranzahl = median(zimmeranzahl),
            .groups = "drop") %>%
  arrange(x_mp, y_mp, date_pseudo_halbjahr) %>%
  group_by(x_mp, y_mp) %>%
  mutate(n_cell = sum(n_cell_date)) %>%
  ungroup() %>%
  mutate(xy_mp = (x_mp-500)*10 + (y_mp-500)/1000) %>%
  complete(xy_mp, date_pseudo_halbjahr) %>%
  group_by(xy_mp) %>%
  fill(everything(), -n_cell_date, .direction = "downup") %>%
  ungroup() %>%
  mutate(n_cell_date = replace_na(n_cell_date, 0)) %>%
  inner_join(erklärende_imp, by = join_by(x_mp, y_mp)) %>%
  inner_join(cells_plz, by = join_by(x_mp, y_mp)) %>%
  left_join(got_fiber_dates, by = join_by(x_mp, y_mp)) %>%
  mutate(got_fiber_date = replace_na(got_fiber_date, 0),
         got_fiber_date_pseudo_halbjahr = replace_na(got_fiber_date_pseudo_halbjahr, 0))

data_kauf_complete %>%
  write_parquet("../Daten/RWI_GEO_REDX/Daten_Kauf/data_kauf_complete.parquet")
```

## Miete

Analog zu den Kauf-Daten.

```{r}
# Einlesen
data_miete <- read_parquet("../Daten/RWI_GEO_REDX/Daten_Miete/data_miete.parquet")

# Imputieren, insb. das Baujahr
data_miete_imp <- data_miete %>%
  mutate(date = ejahr*100 + emonat) %>%
  left_join(dates_pseudo_halbjahr, by = join_by(date)) %>%
  select(date_pseudo_halbjahr, x_mp, y_mp, mietekalt_m2, baujahr, wohnflaeche, zimmeranzahl) %>%
  mice::mice(m = 1, maxit = 1,
             pred = mice::quickpred(., exclude = c("x_mp", "y_mp")), 
             seed = 1) %>%
  mice::complete() %>%
  as_tibble()

# Aggregieren und vervollständigen
data_miete_complete <- data_miete_imp %>%
  group_by(date_pseudo_halbjahr, x_mp, y_mp) %>%
  summarise(mean_mietekalt_m2 = mean(mietekalt_m2),
            n_cell_date = n(),
            median_baujahr = median(baujahr),
            median_wohnflaeche = median(wohnflaeche),
            median_zimmeranzahl = median(zimmeranzahl),
            .groups = "drop") %>%
  arrange(x_mp, y_mp, date_pseudo_halbjahr) %>%
  group_by(x_mp, y_mp) %>%
  mutate(n_cell = sum(n_cell_date)) %>%
  ungroup() %>%
  mutate(xy_mp = (x_mp-500)*10 + (y_mp-500)/1000) %>%
  complete(xy_mp, date_pseudo_halbjahr) %>%
  group_by(xy_mp) %>%
  fill(everything(), -n_cell_date, .direction = "downup") %>%
  ungroup() %>%
  mutate(n_cell_date = replace_na(n_cell_date, 0)) %>%
  inner_join(erklärende_imp, by = join_by(x_mp, y_mp)) %>%
  inner_join(cells_plz, by = join_by(x_mp, y_mp)) %>%
  left_join(got_fiber_dates, by = join_by(x_mp, y_mp)) %>%
  mutate(got_fiber_date = replace_na(got_fiber_date, 0),
         got_fiber_date_pseudo_halbjahr = replace_na(got_fiber_date_pseudo_halbjahr, 0))

data_miete_complete %>%
  write_parquet("../Daten/RWI_GEO_REDX/Daten_Miete/data_miete_complete.parquet")
```

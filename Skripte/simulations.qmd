---
title: "Simulationen"
format: html
---

# Setup

```{r}
library(tidyverse)
library(did)
library(HonestDiD)
source("honest_did_helper.R")
```

# CS21 allgemeine Beispiele

Hier ein simulierter Datensatz um ein paar Beispielgrafiken zu machen um das did Package vorzustellen

```{r}
#| fig-width: 2
#| fig-height: 3

set.seed(1)

# Parameters
n_ids <- 15
n_time <- 10
treatment_percentage <- 0.5  # 20% of ids get treated

# Define multiple treatment groups with unique treatment times and multipliers
treatment_groups <- tibble(
  group = 1:3,  # Example: 3 distinct groups
  treatment_time = c(3, 4, 7),             # Different treatment times for each group
  treatment_multiplier = c(1.5, 2.0, 3), # Different multipliers for each group
  treatment_jump = c(4, 0, 2)
)

# Calculate number of treated IDs
n_treated <- ceiling(n_ids * treatment_percentage)  # Ceiling to ensure at least 20%

# Assign treated_ids to groups, cycling through groups if necessary
treated_assignments <- treatment_groups %>%
  slice(rep(1:n(), length.out = n_treated)) %>%  # Repeat groups as needed
  mutate(id = 1:n_treated) %>%                    # Assign IDs
  select(id, everything())

# Base slopes: eventually-treated IDs can have a different slope to never-treated
base_slopes <- c(rep(1, n_treated), rep(1, n_ids - n_treated))

# Create the panel dataset
dat <- expand_grid(
  id = 1:n_ids,
  time = 1:n_time
) %>%
  # Join treatment group assignments
  left_join(treated_assignments, by = "id") %>%
  # Add treatment indicators and parameters
  mutate(
    first_treat = if_else(!is.na(treatment_time), treatment_time, 0),  # Treatment time per ID
    treat = if_else(first_treat != 0 & time >= first_treat, 1, 0),     # Treatment indicator
    slope = base_slopes[id],                                           # Base slope per ID
    treatment_multiplier = if_else(!is.na(treatment_multiplier), treatment_multiplier, 1) # Multiplier
  ) %>%
  # Generate y values based on treatment status
  group_by(id) %>%
  mutate(
    y = if_else(
      treat == 0,
      slope * time + rnorm(n(), 0, 0.5),  # Before treatment
      slope * first_treat + 
      slope * treatment_multiplier * (time - first_treat) + 
      treatment_jump + 
      rnorm(n(), 0, 0.5)                  # After treatment
    )
  ) %>%
  ungroup() %>%
  # Select relevant columns
  select(time, id, y, treat, first_treat)


# View first few rows
dat

dat %>%
  ggplot(aes(x = time, y = y, color = as.factor(first_treat), group = as.factor(id)))+
  geom_vline(xintercept = treatment_groups$treatment_time, linetype = "dotted")+
  geom_line(alpha = .8)+
  scale_x_continuous(breaks = seq(0, 10, 2))+
  theme_bw()+
  theme(legend.position = "none")+
  labs(color = "Gruppe",
       x = "Zeit", y = "Zielgröße")
ggsave("../Output/plots/did/plot_did_example_data.pdf", width = 2, height = 3, device = cairo_pdf)
```

```{r}
#| fig-width: 4
#| fig-height: 3

dat_att <- att_gt(
  yname         = "y",
  tname         = "time",
  idname        = "id",
  gname         = "first_treat",
  #xformla       = NULL,            # No additional controls in this dataset 
  control_group = "nevertreated", # Too few groups for "nevertreated" default
  clustervars   = "id", 
  data          = dat,
  )

tidy(dat_att) %>%
  mutate(is_treated = time >= group) %>%
  ggplot(aes(x = time, y = estimate, ymin = conf.low, ymax = conf.high, color = is_treated))+
  geom_point()+
  geom_linerange()+
  geom_hline(aes(yintercept = 0), linetype = "dashed")+
  facet_wrap(~group, nrow = 1)+
  scale_color_manual(values = c("#2E8B8B", "#E67E22"))+
  scale_y_continuous(breaks = seq(0, 8, by = 2))+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "Zeit",
       y = "ATT")
ggsave("../Output/plots/did/plot_did_example_att.pdf", width = 4, height = 3, device = cairo_pdf)
```

```{r}
#| fig-width: 2
#| fig-height: 3

dat_att %>%
  aggte(type = "dynamic") %>%
  tidy() %>%
  mutate(is_treated = event.time >= 0) %>%
  ggplot(aes(x = event.time, y = estimate, ymin = conf.low, ymax = conf.high, color = is_treated))+
  geom_linerange()+
  geom_point(size = 1.5)+
  geom_hline(aes(yintercept = 0), linetype = "dashed")+
  scale_color_manual(values = c("#2E8B8B", "#E67E22"))+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "Zeit",
       y = "ATT")
ggsave("../Output/plots/did/plot_did_example_agg_dyn.pdf", width = 2, height = 3, device = cairo_pdf)

dat_att %>%
  aggte(type = "group", max_e = 2) %>%
  tidy() %>%
  filter(group != "Average") %>%
  mutate(group = factor(group, levels = as.character(sort(as.numeric(group))))) %>%
  ggplot(aes(x = estimate, y = group, xmin = conf.low, xmax = conf.high))+
  geom_linerange()+
  geom_point(size = 1.5)+
  geom_vline(aes(xintercept = 0), linetype = "dashed")+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "ATT",
       y = "Gruppe",
       title = element_blank())
ggsave("../Output/plots/did/plot_did_example_agg_group.pdf", width = 2, height = 3, device = cairo_pdf)

dat_att %>%
  aggte(type = "calendar") %>%
  tidy() %>%
  ggplot(aes(x = time, y = estimate, ymin = conf.low, ymax = conf.high))+
  geom_linerange()+
  geom_point(size = 1.5)+
  geom_hline(aes(yintercept = 0), linetype = "dashed")+
  theme_bw()+
  theme(legend.position = "none")+
  labs(x = "Zeit",
       y = "ATT",
       title = element_blank())
ggsave("../Output/plots/did/plot_did_example_agg_calendar.pdf", width = 2, height = 3, device = cairo_pdf)
```

# p-values in CS21

Um rauszufinden, wie sensibel der Wald-Test für die Pretrends und `honestDiD` sind, hier eine Simulation mit einem synthetischen Datensatz.

Was auffällt: Mit vielen Gruppen (Achtung, nicht Gruppen im Sinne von CS21) ist der Wald-Test sehr sensibel. Das heißt, auch winzige Abweichungen bei den Pretrends (z.B. 1% unterschiedliche Steigung) werden erkannt und der p-Wert ist nahe Null.

[Hier](https://chat.maulwurf.fun/share/rny9CO7eNsA-r35oMip_z) eine Erklärung von o1

```{r}
set.seed(1)

# Parameters
n_ids <- 100
n_time <- 10
treatment_time <- 5
treated_ids <- 1:(n_ids*0.2) # 20% of ids get treated
base_slopes <- c(rep(1.2, length(treated_ids)), 
                 rep(1, n_ids - length(treated_ids)))  # Set slope for each id
treatment_multiplier <- 1.5  # Slopes double after treatment
treatment_jump <- 0.5 # Jump in the treatment periode

# Create base data
dat <- expand_grid(
  id = 1:n_ids,
  time = 1:n_time
) %>%
  # Add treatment indicator and first treatment time
  mutate(
    first_treat = if_else(id %in% treated_ids, treatment_time, 0),
    treat = if_else(first_treat != 0 & time >= first_treat, 1, 0)
  ) %>%
  # Generate y values
  group_by(id) %>%
  mutate(
    slope = base_slopes[id],
    y = case_when(
      treat == 0 ~ slope * time + rnorm(n(), 0, 0.5),
      treat == 1 ~ slope * treatment_time + 
                   slope * treatment_multiplier * (time - treatment_time) +
                   treatment_jump + rnorm(n(), 0, 0.5)
    )
  ) %>%
  ungroup() %>%
  select(time, id, y, treat, first_treat)

# View first few rows
dat

# dat %>%
#   ggplot(aes(x = time, y = y, color = as.factor(first_treat), group = as.factor(id)))+
#   geom_line()+
#   theme(legend.position = "none")

# set.seed(1)
# dat %>%
#   filter(id %in% sample(treated_ids, 3) |
#            id %in% sample(setdiff(1:n_ids, treated_ids), 3)) %>%
#   mutate(is_treated = if_else(first_treat == 5, "Treated", "Not Treated")) %>%
#   ggplot(aes(x = time, y = y, color = is_treated, group = as.factor(id)))+
#   geom_line()+
#   scale_x_continuous(breaks = 1:10)+
#   theme_bw()+
#   theme(legend.position = "none")+
#   labs(x = "Zeit", y = "Zielgröße", color = element_blank(), title = element_blank())
# ggsave("../Output/plots/did/plot_did_simulation.pdf", width = 3, height = 3, device = cairo_pdf)
```


```{r}
cs21 = att_gt(
  yname         = "y",
  tname         = "time",
  idname        = "id",
  gname         = "first_treat",
  #xformla       = NULL,            # No additional controls in this dataset 
  control_group = "nevertreated", # Too few groups for "nevertreated" default
  clustervars   = "id", 
  data          = dat,
  base_period   = "universal"
  )
cs21$Wpval

#ggdid(cs21)

cs21_agg_dyn <- aggte(cs21, type = "dynamic",
                      min_e = -5, max_e = 5)
ggdid(cs21_agg_dyn)

# ggdid(cs21_agg_dyn)+
#   scale_x_continuous(breaks = -4:5)+
#   theme_bw()+
#   theme(legend.position = "none")+
#   labs(x = "Zeit (relativ)",
#        y = "ATT",
#        title = element_blank())
# ggsave("../Output/plots/did/plot_did_simulation_agg_dyn_small.pdf", width = 3, height = 3, device = cairo_pdf)
```

```{r}
source("honest_did_helper.R")
# code for running honest_did
# cs21_agg_dyn_honest_smooth <- honest_did(es = cs21_agg_dyn,
#                            e = 0,
#                            type="smoothness")
# cs21_agg_dyn_honest_smooth


cs21_agg_dyn_honest_rel <- honest_did(es = cs21_agg_dyn, 
                          e = 1,
                          type="relative_magnitude",
                          Mbarvec = seq(from = 0, to = 2, by = 0.1)
                          )
cs21_agg_dyn_honest_rel
# Drop 0 as that is not really allowed.
cs21_agg_dyn_honest_rel$robust_ci <- cs21_agg_dyn_honest_rel$robust_ci[-1,]

## -----------------------------------------------------------------------------
# make sensitivity analysis plots
# createSensitivityPlot(cs21_agg_dyn_honest_smooth$robust_ci,
#                       cs21_agg_dyn_honest_smooth$orig_ci)

createSensitivityPlot_relativeMagnitudes(cs21_agg_dyn_honest_rel$robust_ci,
                                         cs21_agg_dyn_honest_rel$orig_ci,
                                         add_xAxis = FALSE)+
  geom_hline(yintercept = 0, linetype = "dashed")+
  theme_bw()+
  theme(legend.position = "none")+
  labs(y = "ATT",
       title = element_blank())
ggsave("../Output/plots/did/plot_did_simulation_agg_dyn_small_honest.pdf", width = 3, height = 3, device = cairo_pdf)
```

Beobachtung: HonestDiD kann (bei relative magnitude) nur sinnvolle Ergebnisse geben, wenn die Ergebnisse der dynamic aggregation (bei dem e) auch statistisch signifikante Ergebnisse hat.
Beispiel: Bei einer kleinen Stichprobe (kleines `n_ids`) und einem niedrigen `treatment_multiplier` (nahe 1) und `treatment_jump` (nahe Null) findet `aggte(cs21, type = "dynamic")` keine signifikanten Ergebnisse. Und dann gibt es auch kein interessantes "breakdown" $\bar{M}$. Interessant wird es dann, wenn bei einer relativ kleinen Stichprobe der `treatment_multiplier` oder `treatment_jump` so gewählt werden, dass die Ergebnisse von `aggte()` nur knapp signifikant sind.
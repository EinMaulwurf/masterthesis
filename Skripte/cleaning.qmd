---
title: "cleaning.qmd"
format: html
---

# Setup

```{r}
#| message: false
#| warning: false

library(tidyverse)
library(arrow)
library(duckdb)
library(sf)
```

# Zensus Daten

Ich lese hier die Daten vom Zensus auf allen drei Rasterebenen (10km, 1km, 100m) ein und benenne die Koordinaten einheitlich. Danach füge ich eine neue Variable hinzu, welche die Rasterebene anzeigt. Anschließend werden die Daten in einem Arrow Dataset gespeichert und können so wesentlich schneller eingelesen werden.

```{r}
# Altersverteilung -----------------------------
alter_10km <- read_csv2("../Daten/Zensus/Alter_in_10er-Jahresgruppen/Zensus2022_Alter_in_10er-Jahresgruppen_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km) %>%
  mutate(across(unter10:a80undaelter, as.numeric))

alter_1km <- read_csv2("../Daten/Zensus/Alter_in_10er-Jahresgruppen/Zensus2022_Alter_in_10er-Jahresgruppen_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km) %>%
  mutate(across(unter10:a80undaelter, as.numeric))

alter_100m <- read_csv2("../Daten/Zensus/Alter_in_10er-Jahresgruppen/Zensus2022_Alter_in_10er-Jahresgruppen_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m) %>%
  mutate(across(unter10:a80undaelter, as.numeric))

# Durchschnittsalter -----------------------------
durchschnittsalter_10km <- read_csv2("../Daten/Zensus/Durchschnittsalter_in_Gitterzellen/Zensus2022_Durchschnittsalter_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km)

durchschnittsalter_1km <- read_csv2("../Daten/Zensus/Durchschnittsalter_in_Gitterzellen/Zensus2022_Durchschnittsalter_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km)

durchschnittsalter_100m <- read_csv2("../Daten/Zensus/Durchschnittsalter_in_Gitterzellen/Zensus2022_Durchschnittsalter_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m)

# Gebäude Baujahre -----------------------------
gebäude_10km <- read_csv2("../Daten/Zensus/Gebaeude_nach_Baujahr_in_Mikrozensus_Klassen/Zensus2022_Gebaeude_nach_Baujahr_in_Mikrozensus_Klassen_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km) %>%
  mutate(across(insgesamt_gebaeude:a2020undspaeter, as.numeric))

gebäude_1km <- read_csv2("../Daten/Zensus/Gebaeude_nach_Baujahr_in_Mikrozensus_Klassen/Zensus2022_Gebaeude_nach_Baujahr_in_Mikrozensus_Klassen_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km) %>%
  mutate(across(insgesamt_gebaeude:a2020undspaeter, as.numeric))

gebäude_100m <- read_csv2("../Daten/Zensus/Gebaeude_nach_Baujahr_in_Mikrozensus_Klassen/Zensus2022_Gebaeude_nach_Baujahr_in_Mikrozensus_Klassen_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m) %>%
  mutate(across(insgesamt_gebaeude:a2020undspaeter, as.numeric))

# Einwohner -----------------------------
einwohner_10km <- read_csv2("../Daten/Zensus/Zensus2022_Bevoelkerungszahl/Zensus2022_Bevoelkerungszahl_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km)

einwohner_1km <- read_csv2("../Daten/Zensus/Zensus2022_Bevoelkerungszahl/Zensus2022_Bevoelkerungszahl_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km)

einwohner_100m <- read_csv2("../Daten/Zensus/Zensus2022_Bevoelkerungszahl/Zensus2022_Bevoelkerungszahl_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m)

# Haushaltsgröße -----------------------------
haushaltsgröße_10km <- read_csv2("../Daten/Zensus/Durchschnittliche_Haushaltsgroesse_in_Gitterzellen/Zensus2022_Durchschn_Haushaltsgroesse_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km)

haushaltsgröße_1km <- read_csv2("../Daten/Zensus/Durchschnittliche_Haushaltsgroesse_in_Gitterzellen/Zensus2022_Durchschn_Haushaltsgroesse_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km)

haushaltsgröße_100m <- read_csv2("../Daten/Zensus/Durchschnittliche_Haushaltsgroesse_in_Gitterzellen/Zensus2022_Durchschn_Haushaltsgroesse_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m)

# Wohnfläche -----------------------------
wohnfläche_10km <- read_csv2("../Daten/Zensus/Durchschnittliche_Wohnflaeche_je_Bewohner_in_Gitterzellen/Zensus2022_Durchschn_Flaeche_je_Bewohner_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km)

wohnfläche_1km <- read_csv2("../Daten/Zensus/Durchschnittliche_Wohnflaeche_je_Bewohner_in_Gitterzellen/Zensus2022_Durchschn_Flaeche_je_Bewohner_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km)

wohnfläche_100m <- read_csv2("../Daten/Zensus/Durchschnittliche_Wohnflaeche_je_Bewohner_in_Gitterzellen/Zensus2022_Durchschn_Flaeche_je_Bewohner_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m)

# Eigentümerquote -----------------------------
eigentümerquote_10km <- read_csv2("../Daten/Zensus/Eigentuemerquote_in_Gitterzellen/Zensus2022_Eigentuemerquote_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km) %>%
  mutate(eigentuemerquote = parse_number(eigentuemerquote, locale = locale(decimal_mark = ",")))

eigentümerquote_1km <- read_csv2("../Daten/Zensus/Eigentuemerquote_in_Gitterzellen/Zensus2022_Eigentuemerquote_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km) %>%
  mutate(eigentuemerquote = parse_number(eigentuemerquote, locale = locale(decimal_mark = ",")))

eigentümerquote_100m <- read_csv2("../Daten/Zensus/Eigentuemerquote_in_Gitterzellen/Zensus2022_Eigentuemerquote_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m) %>%
  mutate(eigentuemerquote = parse_number(eigentuemerquote, locale = locale(decimal_mark = ",")))

# Leerstand -----------------------------
leerstand_10km <- read_csv2("../Daten/Zensus/Leerstandsquote_in_Gitterzellen/Zensus2022_Leerstandsquote_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km) %>%
  mutate(leerstandsquote = parse_number(leerstandsquote, locale = locale(decimal_mark = ",")))

leerstand_1km <- read_csv2("../Daten/Zensus/Leerstandsquote_in_Gitterzellen/Zensus2022_Leerstandsquote_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km) %>%
  mutate(leerstandsquote = parse_number(leerstandsquote, locale = locale(decimal_mark = ",")))

leerstand_100m <- read_csv2("../Daten/Zensus/Leerstandsquote_in_Gitterzellen/Zensus2022_Leerstandsquote_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m) %>%
  mutate(leerstandsquote = parse_number(leerstandsquote, locale = locale(decimal_mark = ",")))

# Miete -----------------------------
nettokaltmiete_10km <- read_csv2("../Daten/Zensus/Zensus2022_Durchschn_Nettokaltmiete/Zensus2022_Durchschn_Nettokaltmiete_10km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_10km,
         x_mp = x_mp_10km,
         y_mp = y_mp_10km)

nettokaltmiete_1km <- read_csv2("../Daten/Zensus/Zensus2022_Durchschn_Nettokaltmiete/Zensus2022_Durchschn_Nettokaltmiete_1km-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_1km,
         x_mp = x_mp_1km,
         y_mp = y_mp_1km)

nettokaltmiete_100m <- read_csv2("../Daten/Zensus/Zensus2022_Durchschn_Nettokaltmiete/Zensus2022_Durchschn_Nettokaltmiete_100m-Gitter.csv") %>%
  janitor::clean_names() %>%
  select(-werterlaeuternde_zeichen) %>%
  rename(gitter_id = gitter_id_100m,
         x_mp = x_mp_100m,
         y_mp = y_mp_100m)
```

Alle Daten verbinden und neue Variable `typ` hinzufügen.

```{r}
zensus_df_list <- list(
  list(alter_10km, alter_1km, alter_100m),
  list(durchschnittsalter_10km, durchschnittsalter_1km, durchschnittsalter_100m),
  list(gebäude_10km, gebäude_1km, gebäude_100m),
  list(einwohner_10km, einwohner_1km, einwohner_100m),
  list(haushaltsgröße_10km, haushaltsgröße_1km, haushaltsgröße_100m),
  list(wohnfläche_10km, wohnfläche_1km, wohnfläche_100m),
  list(eigentümerquote_10km, eigentümerquote_1km, eigentümerquote_100m),
  list(leerstand_10km, leerstand_1km, leerstand_100m),
  list(nettokaltmiete_10km, nettokaltmiete_1km, nettokaltmiete_100m)
)

zensus_final <- zensus_df_list %>%
  map(\(x) {
    x %>%
      map(\(y) {
        y %>%
          mutate(typ = str_extract(gitter_id, "RES(.+)N", group = 1) %>%
                 case_match("10000m" ~ "10km", "1000m" ~ "1km", "100m" ~ "100m"),
                 .before = 1) %>%
          select(-gitter_id)
      }) %>%
      list_rbind()
  }) %>%
  reduce(full_join, by = c("typ", "x_mp", "y_mp"))
```

Schreiben als Arrow Dataset

```{r}
zensus_final %>%
  group_by(typ) %>%
  write_dataset("../Daten/Zensus/Gesamt/")
```

# Breitbandatlas Aggregieren

Die Daten des Breitbandatlas sind auf dem 100m Raster gegeben, für die Auswertungen in Verbindung mit den Sozio- bzw. Immodaten benötige ich aber das 1km Raster. Hier führe ich die Aggregation durch.

Für die Aggregation der Breitband Daten verwende ich später einen gewichteten Mittelwert mit der Anzahl der Haushalte als Gewicht. Dafür lade ich hier die Zensus Daten und berechne die Anzahl der Haushalte für jedes 100m Quadrat.

```{r}
zensus_arrow <- open_dataset("../Daten/Zensus/Gesamt/")

zensus_haushalte_100m <- zensus_arrow %>%
  filter(typ == "100m") %>%
  mutate(anzahl_haushalte = insgesamt_bevoelkerung / durchschn_hh_groesse) %>%
  select(x_mp, y_mp, anzahl_haushalte) %>%
  collect()
```

Jetzt loope ich über alle Zeitpunkte und Variablen. Das ist nötig, weil die Operation sonst zu viel RAM benötigt. Ich lade die Daten des jeweiligen Zeitpunktes und Variable und joine die Anzahl der Haushalte. Ich entferne alle Beobachtungen, bei denen entweder die Anzahl der Haushalte oder der Wert der jeweiligen Variable fehlt. Anschließend wird alles im Long Format in einen Arrow Datensatz geschrieben. Im nächsten Schritt werde ich diesen dann ins Wide Format überführen, dafür müssen aber erst alle Variablen eines Jahres aggregiert worden sein.

```{r}
breitband_100m_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_100m/")

arrow_dates <- breitband_100m_arrow %>%
  distinct(date) %>%
  arrange(date) %>%
  collect() %>%
  pull(date)

arrow_variables <- breitband_100m_arrow %>%
  filter(date == 202312) %>%
  slice_sample(n = 1) %>%
  collect() %>%
  select(starts_with("down_")) %>%
  colnames()

total <- length(arrow_dates) * length(arrow_variables)
counter <- 1

for(d in arrow_dates) {

  gc()

  for(v in arrow_variables) {
    if(counter %% 10 == 0) str_glue("{counter} of {total}") %>% print()

    breitband_100m_arrow %>%
      filter(date == d) %>%
      select(date, x_mp, y_mp, !!sym(v)) %>%
      collect() %>%
      left_join(zensus_haushalte_100m, by = join_by(x_mp, y_mp)) %>%
      mutate(x_mp_1km = floor(x_mp/1000)*1000 + 500,
             y_mp_1km = floor(y_mp/1000)*1000 + 500) %>%
      drop_na(anzahl_haushalte) %>%
      group_by(date, x_mp_1km, y_mp_1km) %>%
      summarise(!!v := weighted.mean(!!sym(v), anzahl_haushalte, na.rm = TRUE),
                .groups = "drop") %>%
      rename(x_mp = x_mp_1km, y_mp = y_mp_1km) %>%
      pivot_longer(cols = all_of(v)) %>%
      mutate(value = round(value, 2)) %>%
      group_by(date, name) %>%
      write_dataset("../Daten/Breitbandatlas/Raster_1km_long/")

    counter <- counter + 1
  }
}
```

Und jetzt wieder zusammenfügen im Wide Format.

```{r}
breitband_1km_long_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_1km_long/")

arrow_names_sorted <- breitband_1km_long_arrow %>%
  distinct(name) %>%
  collect() %>%
  pull(name) %>%
  gtools::mixedsort()

for(d in arrow_dates) {
  print(d)

  breitband_1km_long_arrow %>%
    filter(date == d) %>%
    collect() %>%
    pivot_wider(names_from = name, values_from = value) %>%
    select(date, x_mp, y_mp, all_of(arrow_names_sorted)) %>%
    group_by(date) %>%
    write_dataset("../Daten/Breitbandatlas/Raster_1km/")
}
```

Hier noch ein Vergleich der 100m Daten vs den aggregierten 1km Daten anhand Berlin.

```{r}
breitband_100m_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_100m/")
breitband_1km_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_1km/")

breitband_100m_arrow %>%
  select(date, x_mp, y_mp, down_fn_hh_ftthb_1000) %>%
  filter(date == 202312) %>%
  filter(x_mp %>% between(4531081, 4576579),
         y_mp %>% between(3254012, 3290626)) %>%
  collect() %>%
  st_as_sf(coords = c("x_mp", "y_mp"), crs = 3035) %>%
  st_buffer(dist = 50, endCapStyle = "SQUARE") %>%
  ggplot()+
  geom_sf(aes(fill = down_fn_hh_ftthb_1000), color = NA)+
  scale_fill_viridis_c()+
  theme_void()+
  theme(legend.position = "none")

ggsave("../Output/plots/plot_berlin_100m.pdf", width = 3, height = 2.5)

breitband_1km_arrow %>%
  select(date, x_mp, y_mp, down_fn_hh_ftthb_1000) %>%
  filter(date == 202312) %>%
  filter(x_mp %>% between(4531081, 4576579),
         y_mp %>% between(3254012, 3290626)) %>%
  collect() %>%
  st_as_sf(coords = c("x_mp", "y_mp"), crs = 3035) %>%
  st_buffer(dist = 500, endCapStyle = "SQUARE") %>%
  ggplot()+
  geom_sf(aes(fill = down_fn_hh_ftthb_1000), color = NA)+
  scale_fill_viridis_c()+
  theme_void()+
  theme(legend.position = "none")

ggsave("../Output/plots/plot_berlin_1km.pdf", width = 3, height = 2.5)
```

# Neue Variable: Maximale Geschwindigkeit

Ich extrahiere für jede Zelle und Jahr die maximal verfügbare Internetgeschwindigkeit. Dabei unterscheide ich nach Glasfaser (`_fiber`), nicht-Glasfaser (`_no_fiber`) und dem Maximum aus beidem (`_all`).

```{r}
breitband_1km_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_1km/")

breitband_1km_arrow %>%
  select(date, x_mp, y_mp, contains("ftthb"), contains("hfc"), contains("fttc") ,contains("sonst")) %>%
  collect() %>%
  pivot_longer(cols = starts_with("down"), names_to = "speed_name", values_to = "anteil") %>%
  filter(anteil > 50) %>%
  mutate(type = case_when(
    speed_name %>% str_detect("(hfc|fttc|sonst)") ~ "no_fiber",
    speed_name %>% str_detect("ftthb") ~ "fiber",
    TRUE ~ NA
    )) %>%
  drop_na(type) %>%
  mutate(speed = speed_name %>% str_extract("\\d+$") %>% as.numeric()) %>%
  group_by(date, x_mp, y_mp, type) %>%
  summarise(max_speed = max(speed), .groups = "drop") %>%
  pivot_wider(names_from = type, values_from = max_speed, names_prefix = "max_speed_") %>%
  mutate(max_speed_all = pmax(max_speed_fiber, max_speed_no_fiber, na.rm = TRUE)) %>%
  write_parquet("../Daten/Breitbandatlas/Raster_1km_max_speed.parquet")
```

# Neuer Datensatz: Gitterzellen, bei denen Glasfaser verschwindet

In manchen Gitterzellen verschwindet plötzlich das Glasfaser. Dabei handelt es sich wahrscheinlich um Meldefehler, entweder beim (nicht erfolgten) Ausbau, oder das "Verschwinden" ist nicht korrekt. Ich erstelle einen neuen Dataframe mit den Koordinaten und Datum dieser Zellen (`x_mp`, `y_mp`, `date`). Diese können dann später mit `anti_join()` einfach entfernt werden.

Konkret werden zuerst alle verschiedenen Zeitpunkte in einem Dataframe `distinct_dates` gesammelt. Danach wird `disappeared_fiber` erstellt, ein Dataframe, das die Koordinaten sowie den Zeitpunkt enthält, an dem Glasfaser "verschwindet". Durch einen `left_join()` der `distinct_dates` auf diesen wird das kartesische Produkt aus dem Zeitpunkt des Verschwindens und aller möglichen Zeitpunkte erstellt. Anschließend werden je Zelle nur die Zeitpunkte behalten, die kleiner sind als der Zeitpunkt des Verschwindens.

```{r}
breitband_1km_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_1km/")

distinct_dates <- breitband_1km_arrow %>%
  distinct(date) %>%
  arrange(date) %>%
  collect()

breitband_1km_arrow %>%
  select(date, x_mp, y_mp, down_fn_hh_ftthb_1000) %>%
  filter(!is.na(down_fn_hh_ftthb_1000)) %>%
  to_duckdb() %>%
  arrange(x_mp, y_mp, date) %>%
  mutate(has_fiber = if_else(down_fn_hh_ftthb_1000 > 50, 1, 0)) %>%
  group_by(x_mp, y_mp) %>%
  mutate(got_fiber = has_fiber - lag(has_fiber)) %>%
  ungroup() %>%
  filter(got_fiber == -1) %>%
  distinct(date, x_mp, y_mp) %>%
  collect() %>%
  left_join(distinct_dates, by = character(), relationship = "many-to-many") %>%
  filter(date.y < date.x) %>%
  select(date = date.y, x_mp, y_mp) %>%
  arrange(x_mp, y_mp, date) %>%
  write_parquet("../Daten/Breitbandatlas/Raster_1km_problems.parquet")
```

# Neuer Datensatz: Zeitpunkt, bei dem erstmals Glasfaser vorhanden ist

Hier verwende ich jetzt auch den `breitband_problems` Datensatz

```{r}
breitband_1km_arrow <- open_dataset("../Daten/Breitbandatlas/Raster_1km/")

breitband_1km_arrow %>%
  select(date, x_mp, y_mp, down_fn_hh_ftthb_1000) %>%
  filter(!is.na(down_fn_hh_ftthb_1000)) %>%
  arrange(x_mp, y_mp, date) %>%
  mutate(has_fiber = if_else(down_fn_hh_ftthb_1000 > 50, 1, 0)) %>%
  collect() %>%
  anti_join(breitband_problems, by = join_by(date, x_mp, y_mp)) %>%
  group_by(x_mp, y_mp) %>%
  mutate(got_fiber = has_fiber - lag(has_fiber)) %>%
  ungroup() %>%
  filter(got_fiber == 1) %>%
  select(x_mp, y_mp, got_fiber_date = date) %>%
  group_by(x_mp, y_mp) %>%
  slice_min(order_by = got_fiber_date) %>%
  ungroup() %>%
  write_parquet("../Daten/Breitbandatlas/Raster_1km_got_fiber_date.parquet")
```

# Neuer Datensatz: BBSR Raumgliederung

[Quelle](https://www.bbsr.bund.de/BBSR/DE/forschung/raumbeobachtung/downloads/download-referenzen.html)

Laden der Daten vom BBSR. Ich verwende nicht alle Variablen, sondern vier, die ich für sinvoll halte:
- Degree of Urbanisation (`dgurb`) von [Eurostat](https://ec.europa.eu/eurostat/web/degree-of-urbanisation/methodology) mit 3 Leveln.
- Raumtyp mit Bezug auf die Lage der Gemeinden (`raumtyp_lage`) mit 4 Leveln.
- Stadt- und Gemeindetyp (`gemeindetyp`) mit 5 Leveln.
- Stadt- und Gemeindetyp differenziert (`gemeindetyp_differenziert`) mit 7 Leveln.

Außerdem behalte ich den Amtlichen Gemeindeschlüssel sowie den Regionalschlüssel zum Matchen mit anderen Datensätzen. Der Gemeindename (`gem_name`) dient zur Plausibilisierung.

```{r}
gemeinden_bbsr <- readxl::read_xlsx("../Daten/Raumgliederung_BBSR/raumgliederungen-referenzen-2022.xlsx",
                               sheet = "Gemeindereferenz (inkl. Kreise)",
                               skip = 1,
                               col_types = "text") %>%
  janitor::clean_names() %>%
  select(gem_name = gemeinden_2022_name,
         gem_kennziffer = gemeinden_2022_kennziffer,
         gem_regionalschlussel = gemeinden_2022_regionalschlussel,
         dgurb_kennziffer = degree_of_urbanisation_gemeinden_2022_kennziffer,
         dgurb_name = degree_of_urbanisation_gemeinden_2022_name,
         raumtyp_lage_kennziffer = raumtyp_bezug_lage_gemeinden_2022_kennziffer,
         raumtyp_lage_name = raumtyp_bezug_lage_gemeinden_2022_name,
         gemeindetyp_kennziffer = stadt_und_gemeindetyp_2022_kennziffer,
         gemeindetyp_name = stadt_und_gemeindetyp_2022_name,
         gemeindetyp_differenziert_kennziffer = stadt_und_gemeindetyp_differenziert_2022_kennziffer,
         gemeindetyp_differenziert_name = stadt_und_gemeindetyp_differenziert_2022_name) %>%
  mutate(gem_kennziffer = str_pad(gem_kennziffer, 8, side = "left", pad = "0"),
         gem_regionalschlussel = str_pad(gem_regionalschlussel, 12, side = "left", pad = "0")) %>%
  mutate(dgurb_name = fct_reorder(dgurb_name, as.numeric(dgurb_kennziffer)),
         raumtyp_lage_name = fct_reorder(raumtyp_lage_name, as.numeric(raumtyp_lage_kennziffer)),
         gemeindetyp_name = fct_reorder(gemeindetyp_name, as.numeric(gemeindetyp_kennziffer)),
         gemeindetyp_differenziert_name = fct_reorder(gemeindetyp_differenziert_name, as.numeric(gemeindetyp_differenziert_kennziffer)))

gemeinden_bbsr %>%
  write_parquet("../Daten/Raumgliederung_BBSR/gemeinden_bbsr.parquet")
```

```{r}
all_distinct_cells <- st_read("../Daten/LAEA_Grid/DE_Grid_ETRS89-LAEA_1km.gpkg",
                              query = "SELECT x_mp, y_mp FROM de_grid_laea_1km",
                              as_tibble = TRUE, quiet = TRUE) %>%
  st_as_sf(coords = c("x_mp", "y_mp"), crs = 3035, remove = FALSE)

gemeinden <- st_read("../Daten/Geodaten/DE_VG250.gpkg", layer = "v_vg250_gem", as_tibble = TRUE) %>%
  st_transform(3035) %>%
  janitor::clean_names() %>%
  filter(geofaktor_gf == "mit Struktur Land") %>%
  select(ars = regionalschlussel_ars, ags = gemeindeschlussel_ags, name = geografischer_name_gen, bezeichnung, einwohner = einwohnerzahl_ewz, flaeche = katasterflache_kfl)
```

Mit einem Geospatial Join verbinde ich die Grid-Zellen mit der jeweiligen Gemeinde in der sie liegen (ausgehend vom Mittelpunkt der Zelle). Dann joine ich die BBSR Daten.

Manche Zellen liegen in keiner Gemeinde. Nach visueller Inspektion liegen vielen diese Zellen mit ihrem Mittelpunkt nicht in Deutschland oder es handelt sich um gemeindefreie Gebiete. Da auch die Anzahl gering ist, wird dies als hinnehmbare Ungenauigkeit angesehen.

```{r}
cells_gemeinden_bbsr <- st_join(all_distinct_cells, gemeinden) %>%
  st_drop_geometry() %>%
  left_join(gemeinden_bbsr, by = join_by(ags == gem_kennziffer)) %>%
  drop_na() %>%
  select(x_mp, y_mp, ags, gem_name, dgurb_kennziffer:last_col())

cells_gemeinden_bbsr %>%
  count(gem_name) %>%
  arrange(desc(n))

cells_gemeinden_bbsr %>%
  filter(is.na(gem_name))

cells_gemeinden_bbsr %>%
  write_parquet("../Daten/Raumgliederung_BBSR/Raster_1km_gemeinden_bbsr.parquet")
```

# Neuer Datensatz: Einkommen

Ich verwende Zahlen zum verfügbaren Einkommen auf Kreisebene. Stärker disaggregierte Zahlen konnte ich nicht finden.

```{r}
all_distinct_cells <- st_read("../Daten/LAEA_Grid/DE_Grid_ETRS89-LAEA_1km.gpkg",
                              query = "SELECT x_mp, y_mp FROM de_grid_laea_1km",
                              as_tibble = TRUE, quiet = TRUE) %>%
  st_as_sf(coords = c("x_mp", "y_mp"), crs = 3035, remove = FALSE)

kreise <- st_read("../Daten/Geodaten/DE_VG250.gpkg", layer = "v_vg250_krs", as_tibble = TRUE) %>%
  st_transform(3035) %>%
  janitor::clean_names() %>%
  filter(geofaktor_gf == "mit Struktur Land") %>%
  select(ars = regionalschlussel_ars, ags = gemeindeschlussel_ags, name = geografischer_name_gen, bezeichnung, einwohner = einwohnerzahl_ewz, flaeche = katasterflache_kfl)

kreise_einkommen <- readxl::read_xlsx("../Daten/Geodaten//vgrdl_r2b3_bs2023.xlsx", sheet = "2.4", skip = 4) %>%
  janitor::clean_names() %>%
  drop_na(lfd_nr) %>%
  filter(nuts_3 == 3) %>%
  mutate(name = str_extract(gebietseinheit, "^[^,\\n]+"), .before = 1) %>%
  mutate(regional_schlussel = str_pad(regional_schlussel, width = 5, side = "right", pad = "0")) %>%
  select(ars = regional_schlussel, einkommen = x2022) %>%
  left_join(kreise, by = "ars") %>%
  st_as_sf()

cells_kreise_einkommen <- st_join(all_distinct_cells, kreise_einkommen) %>%
  st_drop_geometry() %>%
  drop_na() %>%
  select(x_mp, y_mp, ars, name, einkommen)

cells_kreise_einkommen %>%
  write_parquet("../Daten/Geodaten/Raster_1km_kreise_einkommen.parquet")
```

# Neuer Datensatz: PLZ Gebiete

```{r}
all_distinct_cells <- st_read("../Daten/LAEA_Grid/DE_Grid_ETRS89-LAEA_1km.gpkg",
                              query = "SELECT x_mp, y_mp FROM de_grid_laea_1km",
                              as_tibble = TRUE, quiet = TRUE) %>%
  st_as_sf(coords = c("x_mp", "y_mp"), crs = 3035, remove = FALSE)

plz <- st_read("../Daten/Geodaten/PLZ_Gebiete_9143106783908117499.gpkg",
                    as_tibble = TRUE, quiet = TRUE) %>%
  st_transform(3035) %>%
  janitor::clean_names() %>%
  select(plz)

cells_plz <- st_join(all_distinct_cells, plz) %>%
  st_drop_geometry() %>%
  drop_na()

cells_plz %>%
  write_parquet("../Daten/Geodaten/Raster_1km_plz.parquet")
```

